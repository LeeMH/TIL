# 15. 여러 프로세스 다루기

## 1. 액터모델

* 엘릭서에서는 액터모델(Actor Model)을 사용한다.

* 액터란 다른 프로세스와 데이터를 전혀 공유하지 않는 독립적인 프로세스를 말한다.

* 엘릭서에서 프로세스는 무겁고 느린 운영체제의 프로세스가 아니다.

* 엘릭서는 얼랭이 제공하는 프로세스를 사용하는데, 얼랭 프로세스는 일반적인 프로세스와 마찬가지로 모든 CPU에서 실행되지만 부하는 매우 적다.

* spawn : 프로세스를 만든다.

* send : 프로세스에 메세지를 보낸다.

* receive : 돌아오는 메세지를 받는다.

## 2. 프로세스 다루기

### 2.1. 간단한 프로세스

* 아래의 코드를 작성하고 iex 컴파일 한다.

```elixir
defmodule SpawnBasic do
  def greet do
    IO.puts "hello"
  end
end
```

```elixir
iex(1)> c("spawn-basic.ex")
[SpawnBasic]

# 함수 실행
iex(2)> SpawnBasic.greet
hello
:ok

iex(3)> spawn(SpawnBasic, :greet, [])
hello
#PID<0.117.0>
```

### 2.2. 프로세스간 메세지 주고 받기

* pid와 send를 이용해서 메세지를 송신하고 receive를 통해서 메세지를 수신할 수 있다.

```elixir
defmodule Spawn1 do
  def greet do
    receive do
      {sender, msg} -> 
        send sender, { :ok, "hello, #{msg}" }
    end
  end
end

pid = spawn(Spawn1, :greet, [])
send pid, {self(), "world!!"}

receive do
  {:ok, message} -> 
    IO.puts message
end
```

```elixir
iex(4)> c("spawn1.ex")
hello, world!!
[Spawn1]
```

### 2.3. 여러개 메세지 주고 받기

* 예제코드를 조금 수정해서 메세지를 하나더 보내고 받아본다.

```elixir
defmodule Spawn1 do
  def greet do
    receive do
      {sender, msg} -> 
        send sender, { :ok, "hello, #{msg}" }
    end
  end
end

pid = spawn(Spawn1, :greet, [])
send pid, {self(), "world!!"}

receive do
  {:ok, message} -> 
    IO.puts message
end

send pid, {self(), "second world!!"}

receive do
  {:ok, message} -> 
    IO.puts message
end
```

* 첫번째 메세지 수신후 터미널이 멈춘다. ctrl+c 를 이용해서 나와야 한다.

* 이유는 greet 메소드가 하나의 메세지만 처리 할수 있기 때문이다.

```elixir
iex(5)> c("spawn2.ex")
warning: redefining module Spawn1 (current version defined in memory)
  spawn2.ex:1: Spawn1 (module)

hello, world!!
```

### 2.4. after를 이용해 멈춤 개선하기

* after 지시어를 사용해서 타임아웃 처리를 한다.

```elixir
defmodule Spawn1 do
  def greet do
    receive do
      {sender, msg} -> 
        send sender, { :ok, "hello, #{msg}" }
    end
  end
end

pid = spawn(Spawn1, :greet, [])
send pid, {self(), "world!!"}

receive do
  {:ok, message} -> 
    IO.puts message
end

send pid, {self(), "second world!!"}

receive do
  {:ok, message} -> 
    IO.puts message
  after 500 -> 
    IO.puts "The greeter has gone away"
end
```

* 타임아웃에 해당하는 메세지가 출력된다.

```elixir
iex(1)> c("spawn2.ex")
hello, world!!
The greeter has gone away
[Spawn1]
```

### 2.5. 여러번 처리하기

* 엘릭서에는 반복문이 없다. 재귀를 이용하자.

```elixir
defmodule Spawn1 do
  def greet do
    receive do
      {sender, msg} -> 
        send sender, { :ok, "hello, #{msg}" }
      greet()
    end
  end
end

pid = spawn(Spawn1, :greet, [])
send pid, {self(), "world!!"}

receive do
  {:ok, message} -> 
    IO.puts message
end

send pid, {self(), "second world!!"}

receive do
  {:ok, message} -> 
    IO.puts message
  after 500 -> 
    IO.puts "The greeter has gone away"
end
```

* 이제 다시 실행하면 정상적으로 두번째 메세지도 수신한다.

```elixir
iex(2)> c("spawn2.ex")
warning: redefining module Spawn1 (current version defined in memory)
  spawn2.ex:1: Spawn1 (module)

hello, world!!
hello, second world!!
[Spawn1]
```

## 3. 재귀, 꼬리 재귀 최적화

* 위와 같이 재귀로 호출하면 함수 호출마다 스택에 프레임이 추가되므로 성능상 문제가 생긴다.

* 하지만 엘릭서의 재귀는 `꼬리 재귀 최적화(tail-call optimization)`가 구현되어 성능상 문제가 없다.

* 단, 꼬리 재귀 최적화가 적용되려면, 반드시 재귀호출이 함수의 마지막에서 이뤄져야 한다.

* 예시로 아래의 경우는 꼬리재귀가 아니다. 재귀 호출이 마지막에 있기는 하지만, 값을 반환한 다음에도 곱하기 연산이 남아 있기 때문이다.

```elixir
def factorial(0), do: 1
def factorial(n), do: n * factorial(n-1)
```

* 위 케이스를 꼬리재귀로 변경하려면 곱셈을 재귀호출 안으로 옮겨야 한다.

```elixir
defmodule TailRecursive do
  def factorial(n), do: _fact(n, 1)
  def _fact(0, acc), do: acc
  def _fact(n, acc), do: _fact(n-1, acc*n)
end
```