# 8. 맵, 키워드리스트, 집합, 구조체

## 1. 무엇을 써야 할까?

|질문|사용할 자료형|
|:---|:---|
|내용을 기준으로 패턴매칭 하고 싶은가?|맵|
|(예를 들어 :name 이라는 키가 있는 경우를 패턴매칭 하고 싶은가?)||
|같은 키로 여러 항목을 저장해야 하는가?|키워드 리스트|
|요소들의 순서가 보장되어야 하는가?|키워드 리스트|
|필드가 정해져 있는가?(즉, 데이터의 구조가 항상 동일한가?)|구조체|
|어떤것에도 해당하지 않는 경우|맵|

## 2. 키워드 리스트

* 키워드 리스트는 일반적으로 함수에 옵션을 전달할때 사용한다.

```elixir
defmodule Canvas do
  @defaults [ fg: "black", bg: "white", font: "Arial" ]

  def draw_text(text, options \\ []) do
    options = Keyword.merge(@defaults, options)
    IO.puts "Drawing text #{inspect(text)}"
    IO.puts "Foregroud: #{options[:fg]}"
    IO.puts "Backgroud: #{Keyword.get(options, :bg)}"
    IO.puts "Font: #{Keyword.get(options, :font)}"
    IO.puts "Pattern: #{Keyword.get(options, :patter, "solid")}"
    IO.puts "Style(get): #{Keyword.get(options, :style)}"
    IO.puts "Style(get_values): #{inspect Keyword.get_values(options, :style)}"
  end
end
```

```elixir
iex(36)> c "example.exs"                                                     
warning: redefining module Canvas (current version defined in memory)
  example.exs:1

[Canvas]
iex(37)> Canvas.draw_text("hello", fg: "red", style: "italic", style: "bold")
Drawing text "hello"
Foregroud: red
Backgroud: white
Font: Arial
Pattern: solid
Style(get): italic
Style(get_values): ["italic", "bold"]
:ok
```

## 3. 맵

* 맵은 랜덤 액세스가 가능한 키/밸류 자료구조로 크기에 상관없이 좋은 성능을 낸다.

```elixir
iex(39)> map = %{name: "Dave", likes: "programming", where: "Dallas"}
%{likes: "programming", name: "Dave", where: "Dallas"}

iex(40)> Map.keys map
[:likes, :name, :where]

iex(41)> Map.values map
["programming", "Dave", "Dallas"]

iex(42)> map[:name]
"Dave"

iex(43)> map.name
"Dave"

iex(44)> map1 = Map.drop map, [:where, :likes]
%{name: "Dave"}

iex(45)> map2 = Map.put map, :also_likes, "ruby"
%{also_likes: "ruby", likes: "programming", name: "Dave", where: "Dallas"}

iex(46)> Map.keys map2
[:also_likes, :likes, :name, :where]
```

## 4. 맵 패턴매칭하기

```elixir
iex(50)> person = %{name: "Dave", height: 1.88}
%{height: 1.88, name: "Dave"}

# map에 key가 존재하는가?
iex(51)> %{name: a_name} = person
%{height: 1.88, name: "Dave"}
iex(52)> %{first_name: a_name} = person
** (MatchError) no match of right hand side value: %{height: 1.88, name: "Dave"}

# map에 나열된 key가 모두 존재하는가?
iex(52)> %{name: _, height: _} = person
%{height: 1.88, name: "Dave"}
iex(53)> %{name: _, age: _} = person   
** (MatchError) no match of right hand side value: %{height: 1.88, name: "Dave"}

# map에 key/value가 모두 존재하는가?
iex(53)> %{name: "Dave"} = person
%{height: 1.88, name: "Dave"}
iex(54)> %{name: "Lee"} = person 
** (MatchError) no match of right hand side value: %{height: 1.88, name: "Dave"}
```

# 5. 맵 패턴매칭 필터링

* 패턴매칭과 필터링을 동시에 진행할수 있다

```elixir
people = [
  %{name: "John", height: 1.95},
  %{name: "Mary", height: 1.25},
  %{name: "Bob", height: 1.75},
  %{name: "Alice", height: 1.95}
]

IO.inspect(for person = %{height: height} <- people, height > 1.9, do: person)
```

```elixir
iex(55)> c "example2.exs"
[%{height: 1.95, name: "John"}, %{height: 1.95, name: "Alice"}]
```

* 함수 선언부에 when 구문을 조합하여 필터링 할수도 있다.

```elixir
defmodule HotelRoom do
  def book(%{name: name, height: height})
  when height > 1.9 do
    IO.puts "need extra large bed for #{name}"
  end

  def book(%{name: name, height: height})
  when height < 1.3 do
    IO.puts "need low shower controll for #{name}"
  end

  def book(person) do
    IO.puts "need standard room for #{person.name}"
  end
end
```

```elixir
iex(3)> people |> Enum.each(&(HotelRoom.book(&1)))
need extra large bed for John
need low shower controll for Mary
need standard room for Bob
need extra large bed for Alice
:ok
```

## 6. 맵 key 패턴 매칭 제약

* 패턴 매칭을 하더라도 key 자체는 바인딩 하지 않는다.

```elixir
iex(6)> %{2 => state} = %{1 => :ok, 2 => :error}
%{1 => :ok, 2 => :error}

iex(7)> state
:error

iex(8)> %{item => state} = %{1 => :ok, 2 => :error}
** (CompileError) iex:8: cannot use variable item as map key inside a pattern. Map keys in patterns can only be literals (such as atoms, strings, tuples, and the like) or an existing variable matched with the pin operator (such as ^some_var)
    (stdlib 3.17) lists.erl:1267: :lists.foldl/3
```

* 변수에 저장된 key로는 매칭이 가능하다.

```elixir
iex(8)> data = %{name: "Dave", state: "TX", likes: "programming"}
%{likes: "programming", name: "Dave", state: "TX"}

iex(9)> for key <- [:name, :likes] do
...(9)>   %{^key => value} = data
...(9)>   value
...(9)> end
["Dave", "programming"]
```

## 7. 맵 수정하기

* 리스트와 달리 맵의 수정은 전체를 순회하지 않아도 가능하다.

* 하지만 역시 원본의 데이터가 수정되는것이 아니고, 수정된 새로운 객체를 리턴하는것이다.

```elixir
iex(12)> m = %{a: 1, b: 2, c: 3}
%{a: 1, b: 2, c: 3} 

iex(13)> m1 = %{m | b: "two", c: "three"}  
%{a: 1, b: "two", c: "three"}

iex(14)> m2 = %{m1 | a: "one"}
%{a: "one", b: "two", c: "three"}
```

* 이 문법은 기존값을 변경하는것이고, 새로운 값을 넣기 위해서는 Map.put_new/3 함수를 이용해야 한다.

