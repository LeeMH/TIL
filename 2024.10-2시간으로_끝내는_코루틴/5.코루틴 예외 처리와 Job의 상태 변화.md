# 1. root 코루틴이란?

* 최상위 코루틴을 `root 코루틴`이라 한다.
* 아래의 코드에서 runBlocking에서 코루틴이 시작되었으므로, 이것이 `root 코루틴`이다.
* 2개의 launch는 `자식 코루틴`이 된다.

```kotlin
fun main(): Unit = runBlocking{  
    val job1 = launch {  
        delay(1_000L)  
        printWithThread("job 1")  
    }  
  
    val job2 = launch {  
        delay(1_000L)  
        printWithThread("job 1")  
    }  
}
```

# 2. 새로운 root 코루틴을 만드는 방법

* `CoroutineScope`을 사용하여 코루틴을 생성한다.
* 아래의 경우, runBlocking은 물론, 각각의 launch도 `root 코루틴`이 된다.

```kotlin
fun main(): Unit = runBlocking{  
    val job1 = CoroutineScope(Dispatchers.Default).launch {  
        delay(1_000L)  
        printWithThread("job 1")  
    }  
  
    val job2 = CoroutineScope(Dispatchers.Default).launch {  
        delay(1_000L)  
        printWithThread("job 1")  
    }  
}
```


# 3. 예외발생

## 3.1. launch에서 예외 발생

- 아래 결과와 같이 예외 발생시, 예외 내용이 출력되고 해당 코루틴은 종료 된다.
-
```kotlin
fun main(): Unit = runBlocking{  
    val job1 = CoroutineScope(Dispatchers.Default).launch {  
        throw IllegalArgumentException()  
    }  
  
    delay(1_000L)  
}
```

![[Pasted image 20241017175351.png]]

## 3.2. async에서 예외 발생 (새로운 코루틴에서 시작한 경우)

- launch와는 달리 아무런 예외도 출력되지 않는다.

```kotlin
fun main(): Unit = runBlocking{  
    val job1 = CoroutineScope(Dispatchers.Default).async {  
        throw IllegalArgumentException()  
    }  
  
    delay(1_000L)  
}
```

![[Pasted image 20241017175544.png]]

* 이유는 launch와 달리 await 함수를 예외가 출력된다.
* 주목해야 할 내용은 예외발생 스레드이다. Dispatcher가 아닌 main 스레드에서 발생했다.
* 왜냐하면, await를 main에서 호출했기 때문이다.

```kotlin
fun main(): Unit = runBlocking{  
    val job1 = CoroutineScope(Dispatchers.Default).async {  
        throw IllegalArgumentException()  
    }  
  
    delay(1_000L)  
    job1.await()  
}
```

![[Pasted image 20241017175747.png]]

## 3.3. async에서 예외발생(자식 코루틴으로 시작한 경우)

- 위의 예제와 달리 아래의 경우 즉시 예외가 출력된다.
- 이유는 위의 에제는 새로운 코루틴(즉, async 자체가 root 코루틴)이기 떼문이고,
- 아래는 async의 부모가 runBlocking이기 때문에 상위로 전파 된다.
- 즉, `예외는 부모 코루틴까지 전파` 된다.

```kotlin
fun main(): Unit = runBlocking{  
    val job1 = async {  
        throw IllegalArgumentException()  
    }  
  
    delay(1_000L)  
}
```

![[Pasted image 20241017180240.png]]

![[Pasted image 20241017180252.png]]

## 3. 예외 전파하지 않기

- `SupervisorJob`을 통해 root 코루틴으로 예외가 전파되는 것을 막을수 있다.

```kotlin
fun main(): Unit = runBlocking{  
    val job1 = async(SupervisorJob()) {  
        throw IllegalArgumentException()  
    }  
  
    delay(1_000L)  
}
```

![[Pasted image 20241017180620.png]]


- 하지만 await이 걸려있다면, `예외가 전파`된다.

```kotlin
fun main(): Unit = runBlocking{  
    val job1 = async(SupervisorJob()) {  
        throw IllegalArgumentException()  
    }  
  
    delay(1_000L)  
    job1.await()  
}
```

![[Pasted image 20241017180833.png]]

# 4. 예외 핸들링 하기

## 4.1. try/catch로 에러를 잡아서 처리한다.

## 4.2. CoroutineExceptionHandler 사용하기.

- `launch`에만 적용이 가능하다.
- `root 코루틴`이 있으면 적용되지 않는다.

```kotlin
fun main(): Unit = runBlocking{  
    val exceptionHandler = CoroutineExceptionHandler { _, throwable  ->  
        // 사앹 저장등 작업을 수행한다.  
        printWithThread("예외!!")  
  
        // 만약 예외를 던지고 싶으면, 이부분에서  처리한다.  
        //throw throwable    }  
    val job1 = CoroutineScope(Dispatchers.Default).launch(exceptionHandler) {  
            throw IllegalArgumentException()  
    }  
  
    delay(1_000L)  
}
```

![[Pasted image 20241017181834.png]]


# 5. 코루틴 예외 한방 정리

## 5.1. CancellationException 

- `취소`로 간주하고 부모 코루틴에게 전파하지 않는다.

## 5.2. 그외 예외

- `실패`로 간주하고 부모 코루틴에게 전파한다.

# 6. 코루틴 상태 전이도

- 사실 코루틴 내부에서는 `취소`, `실패` 모두 `취소됨(Cancelling` 상태로 관리한다.

![[Pasted image 20241017182314.png]]
