# 1. 왜 완료가 두 단계로 나눠져 있을까?

![[Pasted image 20241017190408.png]]

![[Pasted image 20241017190434.png]]

# 2. 코드 예시

- 아래의 코드에서 job1은 정상적으로 종료 된다.
- 하지만 job2는 예외가 발생했다.
- 이 경우, `부모 코루틴`은 `completing` 상태에서 `cancelling` 상태로 변경된다.

```kotlin
fun main(): Unit = runBlocking{  
    val job1 = launch {  
        delay(500L)  
        printWithThread("job1")  
    }  
  
    val job2 = launch {  
        delay(700L)  
        throw IllegalArgumentException("코루틴 실패!!")  
    }  
}
```

![[Pasted image 20241017190756.png]]

- 아래와 같이 예외가 먼저 발생한다면, job1은 실행되지 않는다.
- 예외가 발생하면서, 상태가 `cancelling` 으로 변경되고, `부모는 다시 모든 자식에게 취소를 전파`하기 때문이다.
```kotlin
fun main(): Unit = runBlocking{  
    val job1 = launch {  
        delay(700L)  
        printWithThread("job1")  
    }  
  
    val job2 = launch {  
        delay(600L)  
        throw IllegalArgumentException("코루틴 실패!!")  
    }  
}
```

![[Pasted image 20241017190954.png]]


# 3. Structured Concurrency

- 부모, 자식간 상태가 구조적으로 전파되는 것.
- 수많은 코루틴이 유실되거나 누수되지 않도록 보장.

# 4. 취소와 예외, Structured Concurrency 정리

![[Pasted image 20241017191237.png]]

![[Pasted image 20241017191248.png]]

![[Pasted image 20241017191305.png]]