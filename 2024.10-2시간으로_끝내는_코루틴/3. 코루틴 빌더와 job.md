

# 코루틴 빌더란?

* 코루틴을 새로 만드는 함수를 `코루틴 빌더`라 한다.

# 코루틴을 만드는 방법

## 1. runBlocking

* 내부의 모든 코루틴이 완료될 때까지 스레드를 블로킹 한다.
* 메인함수, 테스트코드등 제한적으로 사용

## 2. launch

* 결과값이 없는 코루틴을 만들때 사용
* launch 실행시 job 객체가 반환됨
* 이 job 객체를 통해, 코루틴을 제어할 수 있다.

### 2.1. job 객체를 통해 코루린 start

```kotlin
fun main(): Unit = runBlocking{  
  
    val job = launch(start = CoroutineStart.LAZY) {  
        printWithThread("hello!!")  
    }  
  
    printWithThread("START")  
    delay(1_000)  
    job.start()  // job 객체를 통해 코루틴을 실행
  
    printWithThread("END")  
}
```

![[Pasted image 20241011192925.png]]

### 2.2. job 객체를 통해 코루린 cancel

```kotlin
fun main(): Unit = runBlocking{  
  
    val job = launch {  
        (1..5).forEach {  
            printWithThread(it)  
            delay(500)  
        }  
    }  
    delay(1_000L)  
    job.cancel()  
}
```

![[Pasted image 20241011193325.png]]

2.3. job 객체를 통해 코루린 join

* join을 호출하면, 해당 코루틴이 완료 될 때까지 대기 한다.

```kotlin
fun main(): Unit = runBlocking{  
  
    val job1 = launch {  
        delay(1_000L)  
        printWithThread("job 1")  
    }  
    job1.join() // job1이 종료된 후 job2가 실행된다.  
  
    val job2 = launch {  
        delay(1_000L)  
        printWithThread("job 1")  
    }  
}
```

![[Pasted image 20241011193731.png]]


## 3. async

* launch와 다르게 `결과값을 반환`할 수 있다.
* async 결과 값은 `Deffered` 객체이지만, Job을 상속받고 있다.
* `await` 함수를 통해 결과값을 가져올 수 있다.
* 단, 코루틴이 완료되지 않은 경우, 완료될 때까지 대기하게 된다.
* `CoroutineStart.LAZY` 실행시, await 호출시 start되며 완료될 때까지 대기한다.

![[Pasted image 20241011193913.png]]

```kotlin
fun main(): Unit = runBlocking{  
    printWithThread("START")  
    val job = async {  
        delay(1_000L)  
        10 + 2  
    }  
  
    printWithThread("result => ${job.await()}")  
}
```

![[Pasted image 20241011194220.png]]